<HTML>
<HEAD>
<TITLE></TITLE>
<META NAME="GENERATOR" Content="Microsoft Visual Studio">
<META HTTP-EQUIV="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<BODY>
<h1>Структура файла 1cv7.md</h1>
<ol>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/intro.html">Введение</a> 
  </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/common-struct.html">Общая 
  структура файла 1cv7.md</a> <font color=green>(updated 28/09/05)</font> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/mms-details.html">Подробнее 
  о Main Metadata Stream</a> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/goods-ref.html">Подробнее 
  о справочнике "Номенклатура"</a> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/folders-struct.html">Еще 
  немного об общей структуре каталогов</a> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/why.html">Зачем 
  это нужно?</a> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/howto-less.html">Как 
  уменьшить размер 1cv7.md?</a> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/howto-repair.html">Как 
  восстановить разрушенный 1cv7.md?</a> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/module.html">Как 
  посмотреть</a> модуль конфигурации, защищенной паролем? <font 
  color=green>(updated 27/09/05)</font> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/zlibeng.html">Каким 
  образом пакуются тексты модулей и пользовательских описаний</a> </li>
  <li><a 
  href="https://web.archive.org/web/20160323232814/http://1c.alterplast.ru/1cv7md/guiddata.html">Подробнее 
  о GuidData</a> <font color=green>(new 28/09/05)</font> 
  <hr>

  <h4>Подробное описание большого количества форматов можно найти в дистрибутиве 
  исходников gcomp'а, в папке Documentation.</h4>
  <hr>
  <font size=-1>в планах на будущее...</font> </li>
  <li>Подробнее о Container.Profile </li>
  <li>Подробнее о Container.Contents </li>
  <li>Подробнее о Main Metadata Stream </li>
  <li>Подробнее о Dialog Stream </li>
  <li>Подробнее о формате moxel </li>
  <li>Список материалов по этой тематике в сети. 
  <h2>Введение</h2>
  <p>Есть так называемые контейнерные файлы: то есть файлы, содержащие внутри 
  себя несколько файлов, которые к тому же могут быть разбиты по дереву 
  подкаталогов. Примерами таких файлов могут служить практически все файлы MS 
  Office. Кем-то совершенно случайно было обнаружено, что такой-же структурой 
  обладают и файлы конфигурации 1С Предприятия - 1cv7.md. Для популярного 
  файлового менеджера <a 
  href="https://web.archive.org/web/20160810115459/http://www.rarlab.com/">FAR</a> 
  существует плагин для просмотра и редактирования таких файлов, скачать который 
  <a 
  href="https://web.archive.org/web/20160810115459/http://1c.alterplast.ru/files/fdb102.zip">можно 
  тут</a> (32 Kb). Родина этого плагина находится по адресу <nobr><a 
  href="https://web.archive.org/web/20160810115459/http://www.7-zip.org/utils.html">www.7-zip.com</a></nobr> 
  </p>
  <p>Для желающих получить более человечное представление внутренней структуры 
  MD сделана <a 
  href="https://web.archive.org/web/20160810115459/http://1c.alterplast.ru/gcomp/index.html">утилита 
  gcomp</a>. </p></li></ol>
<h2>Общая структура файла 1cv7.md</h2>
<p></p>
<ol>
  <li>В каждом каталоге есть служебный файл Container.Contents, в котором 
  описано, какие файлы и каталоги есть в текущей папке. </li>
  <li>Главный каталог, с которого 1С начинает рассмотрение md - Metadata. Там 
  находится уже известный нам Container.Contents, TagStream, Main Metadata 
  Stream и GUIDData. 
  <dl>
    <dt><b><a 
    href="https://web.archive.org/web/20160811110706/http://1c.alterplast.ru/1cv7md/guiddata.html">GUIDData</a></b></dt>
    <dd>содержит в себе информацию о наследовании файлов конфигурации. На 
    содержание именно этого файла опирается 1с, когда говорит, что загружаемая 
    конфигурация не является прямым потомком текущей. <a 
    href="https://web.archive.org/web/20160811110706/http://1c.alterplast.ru/1cv7md/guiddata.html">Почитать 
    подробнее</a>. </dd>
    <dt><b><a 
    href="https://web.archive.org/web/20160811110706/http://1c.alterplast.ru/1cv7md/mms-details.html">Main 
    Metadata Stream</a></b></dt>
    <dd>Содержит основную информацию о всех остальных элементах конфигурации <a 
    href="https://web.archive.org/web/20160811110706/http://1c.alterplast.ru/1cv7md/mms-details.html">Почитать 
    подробнее</a>.</dd>
    <dt><b>TagStream</b></dt></dl>
  <p>В этом потоке лежит все то, что находится в свойствах основного дерева 
  метаданных на закладках "Автор" и "Заставка". То есть информация об авторе с 
  логотипом, название конфигурации и ее заставка.GUIDData - это поток, на 
  основании которого 1С определяет, является ли загружаемая конфигурация прямым 
  наследником текущей. Если в него вглядеться в процессе его изменения, то 
  становится ясным, что при каждом сохранении в начало файла (со смещением 20) 
  дописывается кусочек из 16-ти байт, а в конце те же 16 байт удаляются. То есть 
  получается некое FIFO. </p></li></ol>
<dl>
  <dd>
  <p>Из этого можно сделать несколько выводов. </p>
  <p>Вывод первый. Если мы в конфигуратор загрузили (в режиме "загрузить 
  измененную конфигурацию") конфигурацию А1, и нажали кнопку "Сохранить", то в 
  результате мы получим уже <b>другую</b> конфигурацию (назовем ее Б1), которая 
  будет отличаться от А1 составом потока GUIDData. Соответственно, если потом 
  внести изменения в конфигурацию А1 (получим А2), и попытаться загрузить А2 в 
  Б1, то мы получим сообщение о том, что "Загружаемая конфигурация не является 
  потомком текущей". </p>
  <p>Описываемый эффект часто возникает в ситуации, когда программист сидит дома 
  и пишет конфигурацию, а раз в три дня приезжает к клиенту и загружает ее как 
  измененную. Обычно подобный эффект вызывает изумление. В <b>данном 
  конкретном</b> случае, разумеется, подобное сообщение можно игнорировать. Если 
  же экспериментировать не хочется, то для избежания подобных сообщений сразу 
  после создания конфигурации Б1 ее нуно загрузить поверх А1 (Получим В1), и уже 
  дальнейшее редактирование производить в В1. </p>
  <p>Вывод второй. При коллективной раработке с помощью <a 
  href="https://web.archive.org/web/20160810112728/http://1c.alterplast.ru/gcomp/">GComp</a>, 
  поток GUIDData можно полностью игнорировать и не коммитить вообще. Ибо 
  проблему уникальности идентификаторов метаданных при коллективной разработке 
  решают другими способами. Однако можно и коммитить - хуже не будет. А 
  вдобавок, если коммитить GUIDData, то по истории одного этого файла можно 
  отследить все изменения, сделанные в конфигурации. </p>
  <p>Вывод третий, на первый взгляд парадоксальный. Поскольку длина потока 
  GUIDData ограничена (32020 байт), а как уже было сказано, ротация элементов в 
  нем происходит по принципу FIFO, то становится очевидным, что после 
  определенного числа сохранений (а именно (32020-20) / 16 = 2000) 1С перестает 
  узнавать прямых потомков конфигурации. </p></dd>
  <dd>
  <h2>Подробнее о Main Metadata Stream</h2>
  <p>Этот файл разбит на множество секций, каждая из которых взята в фигурные 
  кавычки. Секции могут быть вложенными. Внутри секции может находиться 
  несколько параметров, разделенных запятыми. Секции одного вида имеют 
  одинаковый набор параметров. Все секции имеют идентификаторы. Эти 
  идентификаторы записаны в первом параметре любой секции. Если секция самого 
  верхнего уровня, то она имеет текстовый идентификатор, обозначающий, какого 
  типа метаданные описаны в этой секции. Например, у констант секция называется 
  Consts, у справочников - SbCnts, у нумераторов документов - DocNumRef, и т. д. 
  Если же секция содержит в себе описание какого-то конкретного объекта 
  метаданных, то идентификатор, как правило, цифровой. Для тех объектов 
  метаданных, которым можно сопоставить некий файл в базе данных, этот 
  идентификатор совпадает с номером файла. Например, справочник "Номенклатура" в 
  комплексной конфигурации имеет идентификатор 33 и файл sc33.dbf. </p>
  <p>Рассмотрим строение секции на примере справочника "Номенклатура". Первым 
  полем, как уже было сказано, является идентификатор. Вторым - тот 
  идентификатор, который задан в конфигураторе. Далее идут комментарий и 
  синоним, а так же другие параметры справочника, такие как длина кода, 
  наименование, подчиненность, вид основного представления, и т. д. </p>
  <p>Затем идет секция описания параметров, называется она "Param", и вся 
  состоит из вложенных секций-параметров. В каждом параметре идет идентификатор, 
  затем название в конфигураторе, комментарий с синонимом, тип данных 
  (U-Неопределенный, N-Число, S-Строка, D-Дата, B-Справочник, O-Документ, 
  E-перечисление, T-Счет, P-ПланСчетов, K-ВидСубконто, C-Календарь, 
  A-ВидРасчета), и ряд параметров, характерных для данного типа данных (длина, 
  неотрицательность, периодичность, индексация, и т. д.). </p>
  <p>И последняя секция - секция форм списков ("Form"). Здесь описаны формы 
  списка нашего справочника. В данной секции так же присутствуют числовой 
  идентификатор формы списка, идентификатор с синонимом и комментарием, как 
  задано в конфигураторе. Например в моей конфигурации, для формы списка 
  "ФормаСписка" идентификатор 34, а для списка "ДляПодбора" - 549. </p></dd></dl>
<h2>Подробнее о справочнике "Номенклатура"</h2>
<p>Справочник как метаданные - структура сложная. Наверное, в компенсацию за 
простоту хранения данных. :)</p>
<p>Метаданные для справочника, кроме файла Main Metadata Stream, находятся аж в 
трех папках. Это папки <b>Subconto</b>, <b>SubFolder</b> и <b>SubList</b>. Как 
можно легко понять из названий, там находятся формы элемента, группы и списков 
соответственно. </p>
<p>Внутри каждой папки находится куча папок с именами типа Subconto_NumberNNN, 
где NNN - идентификатор. Для папок Subconto и SubFolder идентификатор совпадает 
с идентификатором самого справочника, а для папки SubList у каждой формы списка 
свой идентификатор (<a 
href="https://web.archive.org/web/20160810112940/http://1c.alterplast.ru/1cv7md/mms-details.html">указан 
в Main Metadata Stream</a>). В дополнение скажу, что в каждой папке с 
номером-идентификатором, есть только одна подпапка WorkBook, в которой уже и 
находится то, что мы ищем. </p>
<p>Таким образом, описание формы элемента справочника "Номенклатура" можно найти 
в папке <nobr>Subconto\Subconto_Number33\WorkBook.</nobr> А форму списка 
"ДляПодбора" можно найти по пути <nobr>SubList\SubList_Number549\WorkBook</nobr> 
</p>
<p>Содержимое каждой папки <b>WorkBook</b> типовое. Она содержит максимум пять 
типов файлов. </p>
<ol>
  <li>Уже знакомый нам <b>Container.Contents</b> </li>
  <li><b>Container.Profile</b>. Его назначение мне неизвестно, появился он 
  только в версии 7.7 и может вообще отсутствовать. Более того, даже если он 
  есть, а мы его удалим, то конфигурация не потеряет работоспособности. </li>
  <li><b>Dialog Stream</b>. Тут находится экранная форма. Просто нажмите F3 и 
  посмотрите. </li>
  <li><b>MD Programm text</b>. Здесь лежит модуль формы. По F3 посмотреть не 
  получится - он запакован zip'ом с обрезанным заголовком. Для просмотра 
  используем <a 
  href="https://web.archive.org/web/20160810112940/http://1c.alterplast.ru/gcomp/index.html">gcomp</a>. 
  </li>
  <li><b>Page.N</b>. N - произвольное число, часто - 1 :). Печатная форма. 
  Формат хранения - оригинальный от 1С. Если печатной таблицы в форме нет - файл 
  отсутствует. Если печатных форм несколько - то и таких файлов будет несколько, 
  различающиеся номерами. Пустая печатная форма обладает характерной длиной 
  файла 147 байт (в 7.5 - 139). </li></ol>
<h2>Еще немного об общей структуре каталогов</h2>
<p>Пройдемся теперь по всем каталогам и выясним их назначение. Внутри каждого 
каталога структура практически одинаковая: множество нумерованных подкаталогов, 
содержащих ту или иную часть метаданных. При этом номера соответствуют 
идентификаторам объектов из Main Metadata Stream. </p>
<p>Итак: </p>
<dl>
  <dt><b>AccountChart</b> </dt>
  <dd>Тут лежат экранные формы счетов. Поскольку форма счета в конфигурации 
  может быть только одна, то и поддиректория здесь тоже только одна. Всегда. 
  </dd>
  <dt><b>AccountChartList</b> </dt>
  <dd>Тут лежат экранные формы списка планов счетов. </dd>
  <dt><b>CalcJournal</b> </dt>
  <dd>Экранные формы журналов расчетов. </dd>
  <dt><b>CalcVar</b> </dt>
  <dd>Обработки. </dd>
  <dt><b>Document</b> </dt>
  <dd>Документы. Тут все, кроме модуля проведения документа. </dd>
  <dt><b>GlobalData</b> </dt>
  <dd>Общие таблицы. </dd>
  <dt><b>Journal</b> </dt>
  <dd>Формы журналов документов. </dd>
  <dt><b>Metadata</b> </dt>
  <dd><a 
  href="https://web.archive.org/web/20160811111333/http://1c.alterplast.ru/1cv7md/common-struct.html">См. 
  выше</a>. </dd>
  <dt><b>Operation</b> </dt>
  <dd>Экранная форма бухгалтерской операции. </dd>
  <dt><b>OperationList</b> </dt>
  <dd>Экранные формы журналов операций. </dd>
  <dt><b>Picture</b> </dt>
  <dd>Галерея картинок конфигурации. </dd>
  <dt><b>ProvList</b> </dt>
  <dd>Экранные формы журналов проводок. </dd>
  <dt><b>Report</b> </dt>
  <dd>Отчеты. </dd>
  <dt><b>Subconto</b> </dt>
  <dd>Экранные формы элементов справочников. </dd>
  <dt><b>SubFolder</b> </dt>
  <dd>Экранные формы групп справочников. </dd>
  <dt><b>SubList</b> </dt>
  <dd>Экранные формы форм списков справочников. </dd>
  <dt><b>TypedText</b> </dt>
  <dd>Эта директория сильно отличается от предыдущих. Тут находятся: Модули 
  типов расчетов (каталоги CalcArg_Number*), Глобальный модуль (каталог 
  ModuleText_Number1) Модули проведения документов (каталоги Transact_Number*), 
  а так же описания всех объектов метаданных (каталоги UserHelp_Number*). </dd>
  <dt><b>UserDef</b> </dt>
  <dd>Тут хранятся описания интерфейсов (папка Page.1) и наборы прав 
  пользователей (папка Page.2). Формат хранения человеконечитаемый, пользуемся 
  <a 
  href="https://web.archive.org/web/20160811111333/http://1c.alterplast.ru/gcomp/index.html">gcomp</a>. 
  </dd></dl>
<h2>Зачем все это нужно?</h2>
<p>У читающего все это может возникнуть резонный вопрос: а зачем все это нужно 
на практике, какое народо-хозяйственное значение? Разумеется, все не просто 
так.</p>
<p>Во-первых, кому-то просто может оказаться интересно: что же там понапихано в 
двенадцати (уже семнадцати) мегабайтах комплексной конфигурации? И, возможно, 
этот объем можно как-то уменьшить, не снижая функциональности?</p>
<p>Во-вторых, иногда, после каких-то сбоев, при попытке запустить 1С:Предприятие 
возникают ошибки с непонятной диагностикой навроде: 
<nobr>C:\windows\temp\1cv7.md\Metadata\Main Metadata Stream</nobr> - плохой 
путь. Теперь Вы хотя-бы понимаете, что это означает, и при удачном стечении 
обстоятельств можете битый 1cv7.md починить самостоятельно. </p>
<p>В-третьих, как оказывается, система защиты файла 1cv7.md паролем от чтения и 
записи не такая уж и абсолютная, как может показаться с первого взгляда.</p>
<p>В-четвертых, получив доступ к структуре данных, можно написать стороннюю 
программу обмена данных с 1С, которая будет работать с любой конфигурацией.</p>
<p>В-пятых, зная структуру внешне монолитного файла конфигурации, можно 
организовать <a 
href="https://web.archive.org/web/20160810120627/http://1c.alterplast.ru/gcomp/index.html">совместный 
доступ</a> к нему несколькими разработчиками.</p>
<p>Да и вообще, умный человек найдет применение данному знанию.</p>
<h4>Как уменьшить размер файла 1cv7.md</h4>
<p>Во-первых, надо четко понимать, что контейнерный файл - своеобразная база 
данных. А базы данных имеют обыкновение хранить в себе пустые места. Например, в 
dbf удаленные записи не удаляются, а освобождаются для последующих записей. md - 
не dbf, но и в нем при определенных действиях возникают "дырки".</p>
<p>Сохранение файла 1cv7.md может происходить двума способами. Простое 
сохранение без лишних вопросов происходит, если изменения коснулись только в 
модулей, а так же печатных и экранных форм. Сохранение с анализом изменений и 
возможной реорганизацией БД происходит в тех случаях, когда она предполагает 
изменение структуры данных. Простейший способ этого добиться, не изменяя 
конфигурацию - добавить и тут же удалить новую константу или реквизит любого 
справочника/документа. Можно так же зайти в свойства любого реквизита или 
объекта, и в комментарии добавить и тут же удалить пробел (я именно так и 
делаю). </p>
<p>Так вот: только после сохранения с анализом изменений мы можем получить 
1cv7.md минимального размера для текущей функциональности.</p>
<p>Иногда мне кажется, что я не всегда внятно излагаю :), поэтому <a 
href="https://web.archive.org/web/20140226184751/http://1c.alterplast.ru/1cv7md/howto-less-1.html">вот 
тут</a> можно посмотреть описание того же эффекта другими людьми.</p>
<p>Вместо сохранения измененной конфигурации - можно еще перепаковать 
конфигурацию <a 
href="https://web.archive.org/web/20140226184751/http://1c.alterplast.ru/gcomp/index.html">gcomp'ом</a> 
</p>
<hr>

<p>Во-вторых, как уже было сказано чуть выше, присутствие или отсутствие файлов 
container.profile никак не влияет на функциональность конфигурации. 
Соответственно, мы можем удалить все такие файлы с помощью плагина к FAR'у, 
потом загрузить получившуюся конфигурацию как измененную, сохранить, и получить 
выигрыш по 512 байт на каждый такой файл.</p>
<p>В качестве необходимого дополнения хочется добавить, что эти файлы возникают 
в каталогах сами собой, когда вы начинаете редактировать соответствующие им 
объекты метаданных.</p>
<p>Если вам лень перебирать ручками все папки в поисках потоков 
Container.Profile - воспользуйтесь <a 
href="https://web.archive.org/web/20140226184751/http://1c.alterplast.ru/gcomp/index.html">утилитой 
gcomp</a>, и с ее помощью перепакуйте конфигурацию с ключом --no-profiles. </p>
<hr>

<p>В-третьих, после вдумчивого рассмотрения всех каталогов, я обнаружил одну 
забавную особенность каталога Journal. В нем оказались каталоги с 
идентификаторами, для которых не существует форм журналов. Однако, эти 
идентификаторы порой совпадали с идентификаторами самих журналов. Вероятно, еще 
в версии 7.0 (я знаком с ней весьма поверхностно, поэтому не могу утверждать 
наверняка), журналы документов могли иметь только одну форму списка. Очевидно, 
что эта форма имела тот же идентификатор, что и сам журнал. Когда же в версии 
7.5 появилась возможность заводить несколько форм для одного журнала, 
идентификаторы форм, очевидно, пришлось поменять. Однако при преобразовании 
конфигурации из старого формата "старые" формы, видимо, забыли удалить. Эти 
формы можно легко опознать по идентификатору - они все меньше 900. В качестве 
дополнительного подтверждения того, что эти каталоги абсолютно излишни на 
текущий момент, могу указать на то, что в соответствующем Container.Contents из 
каталога Journal нет ни одного упоминания о том, что такие папки должны 
присутствовать.</p>
<p>В комплексной 2.6 таких "забытых" форм 13 штук. Если учесть, что каждая 
состоит как минимум из пяти файлов и одного каталога, то нетрудно посчитать, что 
их удаление принесет нам 6 * 13 * 512 = килобайт 40 как минимум. А за счет того, 
что экранные формы меньше трех кластеров почти никогда не занимают, реальный 
выигрыш наверняка окажется вдвое значительнее. </p>
<p>И здесь поможет перепаковка конфигурации <a 
href="https://web.archive.org/web/20140226184751/http://1c.alterplast.ru/gcomp/index.html">gcomp'ом</a>. 
И даже никаких опций не нужно. </p>
<hr>

<p>Более детальное исследование экранных форм показало, что для каждого объекта 
на форме хранится название того слоя, которому этот элемент принадлежит. По 
умолчанию, название единственного слоя - "Основной". Если слой один, а объектов 
на форме два десятка, то постым переименованием слоя в "О", можно добиться 
экономии 7 * 20 = 140 байт. И если повезет, форма станет занимать на один 512-ти 
байтный блок меньше. Если Вам кажется, что это мелочь - вспомните, сколько 
экранных форм в конфигурации.</p>
<p>Здесь готового решения нету. Однако теоретически можно написать скриптик, 
который переколбасит разобранную <a 
href="https://web.archive.org/web/20140226184751/http://1c.alterplast.ru/gcomp/index.html">gcomp'ом</a> 
конфигурацию, после чего собрать ее обратно. </p>
<hr>

<p>Вспомним о пустых таблицах. Они занимают один кластер, то есть, 512 байт. 
Просто удивительно, насколько их много, особенно в формах журналов, обработках и 
формах списков справочников (то есть там, где они абсолютно не нужны).</p>
<p>И здесь у <a 
href="https://web.archive.org/web/20140226184751/http://1c.alterplast.ru/gcomp/index.html">gcomp'а</a> 
нашлась опция. --no-empty-mxl называется. </p>
<hr>

<p>Что касается справочников. У справочника, как мы помним, есть аж три формы: 
списка, группы и элемента. Так вот, если в справочнике один уровень, то форма 
группы, очевидно, не нужна. Если справочник редактируется только в списке, то не 
нужна еще и форма элемента. И если первую ситуацию 1С отслеживает и предлагает 
удалить неиспользуемую форму группы, то ненужную форму элемента не только нельзя 
удалить штатными способами, но она еще и автоматически будет создана при первой 
попытке в нее войти (что-то MS запахло, не правда ли?). Удалить такую форму 
можно только хирургически, читай, с помощью плагина DocFile Browser. Главное, не 
забыть удалить ссылку на удаленный каталог в Subconto\Container.Contents </p>
<p>Данная тонкая хирургия <a 
href="https://web.archive.org/web/20140226184751/http://1c.alterplast.ru/gcomp/index.html">gcomp'у</a> 
неподвластна. </p>
<hr>

<p>Еще одно поле для деятельности - картинки. Для <a 
href="https://web.archive.org/web/20140226184751/http://1c.alterplast.ru/gcomp/index.html">gcomp'а</a> 
создан скрипт (show_pics), который показывает статистику по используемым (и 
главное - по неиспользуемым) картинкам. А картинки могут быть большими, очень 
большими, и воистину огромными. </p>
<hr>

<p>Однако самый эффективный способ уменьшения размера конфигурации - удаление 
лишнего функционала и оптимизация существующего. Комплексная в этом смысле - 
непаханное поле. Впрочем, это уже совсем другая история... </p>
<h2>Как восстановить разрушенный 1cv7.md</h2>
<p>Для начала немного о диагностике. Если при запуске или работе 1С выдается 
сообщение "Плохой путь" или "не найден файл" или что-то такого плана, после чего 
следует на первый взгляд безумный путь, навроде 
<nobr>D:\temp\~mdAB.tmp\Subconto\Subconto_Number33\WorkBook\Dialog 
Stream</nobr>, то во-первых, нужно знать, что во время конфигурирования текущая 
конфигурация храниться в каталоге TEMP (там, куда смотрит соотв. переменная 
окружения), и хранится под именем ~md??.tmp, где вместо вопросительных знаков 
присутствуют шестнадцатеричные цифры (чтобы различать конфигурации от нескольких 
разных конфигураторов, запущенных одновременно).</p>
<p>Далее: обладая могучим знанием структуры файла 1cv7.md мы можем однозначно 
определить, что в данном случае произошел какой-то сбой в экранной форме 
элемента справочника "Товары" ("Номенклатура").</p>
<p>В моем опыте я однажды столкнулся именно с такой ошибкой. После вдумчивого 
рассмотрения диалоговой формы обнаружилось, что в одном месте вместо числового 
параметра 12 стояло 1". Вроде как программа лишний раз нажала на Shift :). После 
соответствующей замены все заработало.</p>
<p>Это, разумеется довольно простой случай, и я понимаю, что Вам может повести 
не так сильно, как мне, но во всяком случае, без данного знания и без бэкапов 
конфигурации программист оказывается абсолютно беспомощным перед подобным 
проблемами.</p>
<p>[добавление от 27.03.2003] Совсем недавно я получил сообщение сбое файла 
конфигурации, сильно похожем на описанный выше. Оказывается, 1С любит клавишу 
Shift :))</p>
<hr>

<p>Много работы может взять на себя <a 
href="https://web.archive.org/web/20140222112912/http://1c.alterplast.ru/gcomp/index.html">утилита 
gcomp</a>. Иногда для починки конфигурации достаточно простой перепаковки. Но 
даже если перепаковка не помогла - отладочная информация, сообщаемая gcomp'ом 
(ключи -v и -vv) почти всегда поможет точно определить проблемное место. </p>
<hr>

<p>Дополнительные соображения, не относящееся напрямую к ремонту конфигурации: 
</p>
<ol>
  <li>В папке TEMP хранятся дополнительные копии конфигурации, которые можно 
  попробовать использовать, если других резервных копий не осталось :). </li>
  <li>Если у вас в процессе конфигурирования часто вылетает 1С/винда/вырубают 
  питание, то помните о том, что ваш TEMP медленно, но верно заполняется 
  немаленькими файлами. Если упустить контроль над этим процессом - может 
  выстрелить. </li></ol>
<p><font face=System></font>&nbsp;</p>
<h2>Как посмотреть модуль конфигурации, закрытой паролем?</h2>
<p>С уже полученными знаниями это очень просто. Достаточно сказать, что штатный 
способ установки пароля на конфигурацию основано на шифровании содержимого двух 
контейнеров: Main Metadata Stream и глобального модуля. Все остальное остается в 
изначальном виде. Потому мы можем создать свою конфигурацию (можно пустую), 
открыть защищенную конфигурацию плагином DocFile Browser, найти в ней 
местоположение интересующего нас контейнера, выгрузить его и загрузить в нашу 
пустую конфигурацию вместо глобального модуля. Теперь открыв нашу конфигурацию 
конфигуратором, мы в глобальном модуле увидим то, что нам так интересно. </p>
<p>Применяя эту же технологию можно так же посмотреть содержимое любых экранных 
и печатных форм. Более того, новую конфигурацию создавать вовсе необязательно. 
Файлы внешних отчетов (*.ert) так же имеют контейнерную структуру, так что 
экранную форму, модуль и печатные формы можно загружать в ваш внешний отчет. 
</p>
<p>Разумеется, что для целей полной реконструкции (взлома) защищенной 
конфигурации этот метод не подходит, ибо он не дает возможности увидеть 
содержимое ни структуры метаданных, ни глобального модуля. Однако он дает 
прекрасное понимание того факта, что если вы хотите надежно защитить свои 
разработки в 1С, то штатными методами (и некоторыми сторонними) вам не обойтись. 
</p>
<p>Необходимое предупреждение. Хочется напомнить, что конфигурация 1С является 
объектом авторского права. Соответственно, несанкционированный доступ к исходным 
текстам конфигурации может быть квалифицирован по статье 146 УК РФ (Нарушение 
авторских и смежных прав). </p>
<h1>Как пакуются тексты модулей.</h1>
<p>Теория очень проста. Это zip с обрезанным заголовком. Сама 1С пользуется 
библиотекой zlibeng.dll, которая входит в поставку самой 1С. Этим же способом 
пользуются и gcomp, и 1С++. Надо сказать, что исходный код <a 
href="https://web.archive.org/web/20140226193247/http://1c.alterplast.ru/gcomp/">gcomp</a> 
плохо пригоден для изучения приемов работы со zlibeng.dll. Гораздо лучше для 
этого подходит код компоненты <a 
href="https://web.archive.org/web/20140226193247/http://1c.alterplast.ru/faq/1cpp.html">1С++</a>. 
А если точнее, то код метода CModuleString::LoadModule() в той части, где 
происходит загрузка текста модуля из ert файла. Этот код приведен ниже: </p>
<p>
<table border=1 width="100%" bgcolor=white>
  <tr>
    <td><pre>bool CModuleString::LoadModuleFromERT(const CString&amp; strFileName)
{
  IStoragePtr pStgRoot;
  IStorage* pStorage = NULL;
  HRESULT hr;
  USES_CONVERSION;
  hr = ::StgOpenStorage(
          T2COLE(strFileName),
          NULL,
          STGM_READ | STGM_SHARE_DENY_WRITE,
          //STGM_READ,
          NULL,
          0,
          &amp;pStorage);

  if (FAILED(hr))
  {	//ошибка
    CString StrError;
    StrError = "Не удалось прочитать файл: ";
    StrError += strFileName;
    pBkEndUI-&gt;DoMessageLine(StrError, mmBlackErr);
    return false;
  }
  pStgRoot.Attach(pStorage, false);

  IStreamPtr pStream;
  IStream *pIStr = NULL;
  hr = pStgRoot-&gt;OpenStream(T2COLE("MD Programm text"),0,STGM_READ | STGM_SHARE_EXCLUSIVE,0,&amp;pIStr);
  if( FAILED(hr) )
  {
    pBkEndUI-&gt;DoMessageLine("failed IStorage::OpenStream", mmBlackErr);
    return false;
  }
  pStream.Attach(pIStr, false);

  IStreamPtr pStreamOut;
  pIStr = NULL;
  if (S_OK != CreateStreamOnHGlobal(NULL, TRUE, &amp;pIStr))
  {
    pBkEndUI-&gt;DoMessageLine("error in CreateStreamOnHGlobal", mmBlackErr);
    return false;
  }

  pStreamOut.Attach(pIStr, false);
  try
  {
    IzlibEnginePtr iLibEngine;
    iLibEngine.CreateInstance(L"V75.zlibEngine");

    hr = iLibEngine-&gt;pkDecompress(pStream, pStreamOut);

    if (FAILED(hr))
    {
      pBkEndUI-&gt;DoMessageLine("error iLibEngine-&gt;pkDecompress", mmBlackErr);
      return false;
    }

    STATSTG St;
    pStreamOut-&gt;Stat(&amp;St, STATFLAG_NONAME);
    ULONG cbStreamSizeOut = St.cbSize.LowPart;
    LPTSTR lpStr = GetBufferSetLength(cbStreamSizeOut);
    if (lpStr == NULL)
    {
      pBkEndUI-&gt;DoMessageLine("lpStr == NULL", mmBlackErr);
      return false;
	}

    LARGE_INTEGER __zero;
    __zero.QuadPart = __int64(0);
    if (pStreamOut-&gt;Seek(__zero, 0, NULL) != S_OK)
    {
      pBkEndUI-&gt;DoMessageLine("pStreamOut-&gt;Seek(__zero, 0, NULL) != S_OK", mmBlackErr);
      return false;
    }

    ULONG pcbRead = 0;

    // main job here
	if (pStreamOut-&gt;Read(&amp;lpStr[0], cbStreamSizeOut, &amp;pcbRead) != S_OK)
    
	{
      pBkEndUI-&gt;DoMessageLine("pStreamOut-&gt;Read(&amp;lpStr[0], cbStreamSizeOut, &amp;pcbRead) != S_OK", mmBlackErr);
      return false;
    }

  }
  catch (_com_error&amp; err)
  {
    CString str;
    str.Format("V75.zlibEngine Error:%s", err.ErrorMessage());
    pBkEndUI-&gt;DoMessageLine(str, mmBlackErr);
    return false;
  }

  return true;
}

</pre></td></tr></table></p>
<p>Однако если не хочется закладываться на наличие на компьютере установленной 
1С, или просто таскать за собой zlibeng.dll - то можно использовать и другие 
методы. Например скачать и посмотреть <a 
href="https://web.archive.org/web/20140226193247/http://1c.alterplast.ru/1cv7md/www.mmf.newmail.ru%5CZlib.zip">www.mmf.newmail.ru\Zlib.zip</a>. 
Пример использования (так же любезно предоставленный MMF) приведен ниже. 
<table border=1 width="100%" bgcolor=white>
  <tr>
    <td><pre>unction GetErtModuleText(const FileName : string): string;
var
  RootStg: IStorage;
  MetaStream: IStream;
  StringStream: TStringStream;
  OS: TOLEStream;
begin
  Result := '';
  OLECheck(StgOpenStorage(StringToOLEStr(FileName),
                       nil, STGM_READ or STGM_DIRECT
                       or STGM_SHARE_EXCLUSIVE,
                       nil, 0, RootStg));
  OLECheck(RootStg.OpenStream(StringToOLEStr('MD Programm text'),
    nil, STGM_DIRECT or STGM_READ or STGM_SHARE_EXCLUSIVE, 0, MetaStream));
  StringStream := TStringStream.Create('');
  try
    OS := TOleStream.Create(MetaStream);
    try
      try
        OS.Position := 0;
        ZDecompressStream(OS, StringStream);
      finally
        OS.Free;
      end;
      Result := StringStream.DataString;
    except
    end;
  finally
    StringStream.Free;
  end;
end;
</pre></td></tr></table></p>
<p>GUIDData - это поток, на основании которого 1С определяет, является ли 
загружаемая конфигурация прямым наследником текущей. Если в него вглядеться в 
процессе его изменения, то становится ясным, что при каждом сохранении в начало 
файла (со смещением 20) дописывается кусочек из 16-ти байт, а в конце те же 16 
байт удаляются. То есть получается некое FIFO. </p>
<p>Из этого можно сделать несколько выводов. </p>
<p>Вывод первый. Если мы в конфигуратор загрузили (в режиме "загрузить 
измененную конфигурацию") конфигурацию А1, и нажали кнопку "Сохранить", то в 
результате мы получим уже <b>другую</b> конфигурацию (назовем ее Б1), которая 
будет отличаться от А1 составом потока GUIDData. Соответственно, если потом 
внести изменения в конфигурацию А1 (получим А2), и попытаться загрузить А2 в Б1, 
то мы получим сообщение о том, что "Загружаемая конфигурация не является 
потомком текущей". </p>
<p>Описываемый эффект часто возникает в ситуации, когда программист сидит дома и 
пишет конфигурацию, а раз в три дня приезжает к клиенту и загружает ее как 
измененную. Обычно подобный эффект вызывает изумление. В <b>данном 
конкретном</b> случае, разумеется, подобное сообщение можно игнорировать. Если 
же экспериментировать не хочется, то для избежания подобных сообщений сразу 
после создания конфигурации Б1 ее нуно загрузить поверх А1 (Получим В1), и уже 
дальнейшее редактирование производить в В1. </p>
<p>Вывод второй. При коллективной раработке с помощью <a 
href="https://web.archive.org/web/20140227113720/http://1c.alterplast.ru/gcomp/">GComp</a>, 
поток GUIDData можно полностью игнорировать и не коммитить вообще. Ибо проблему 
уникальности идентификаторов метаданных при коллективной разработке решают 
другими способами. Однако можно и коммитить - хуже не будет. А вдобавок, если 
коммитить GUIDData, то по истории одного этого файла можно отследить все 
изменения, сделанные в конфигурации. </p>
<p>Вывод третий, на первый взгляд парадоксальный. Поскольку длина потока 
GUIDData ограничена (32020 байт), а как уже было сказано, ротация элементов в 
нем происходит по принципу FIFO, то становится очевидным, что после 
определенного числа сохранений (а именно (32020-20) / 16 = 2000) 1С перестает 
узнавать прямых потомков конфигурации. </p>

<!-- Insert HTML here -->
<p>&nbsp;</p>

</BODY>
</HTML>